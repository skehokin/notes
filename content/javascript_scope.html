<!doctype html>
<html>
<head>
<title> Web Dev Notes - JS scope</title>

<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../notes.css" rel="stylesheet">

</head>
<body>
<header>
	<h1 class="page-head">
		Web Dev Notes - Javascript Scope
	</h1>
</header>
<main class="summary">
<header>
<h2 class="summary-head"> Summary:</h2>
<p>Scope is an intermediate Javascript concept, detailing the area of code which is governed by certain variables and similar. Here it is further elucidated.</p>
</header>

<article>
<h3>Lexical Scope</h3>
<p>
	This means the area of code where a variable can be refered to by name without getting access errors, basically the area where a variable name has meaning, has a specific variable assigned to it. This is divided into a number of different named scopes.
</p>
<h4>Global Scope</h4>
<p>
This is essentially the area outside any functions. A variable defined in the global scope can be accessed anywhere in the file, including within functions. In some JS programs, global scope is shared across files.
</p>

<h4>New Lexical Scopes</h4>
<p>
Any variable defined within a function can only be accessed from within that same function. A function's own variable name, being inside the global scope, can also be accessed within that function's scope.

However, if you <strong> don't specifically define the variable using "var", </strong> the variable will actually be added to the <strong>global</strong> scope, rather than the function's.
</p>

<h4>Things That Don't Scope</h4>
<p>
Javascript doesn't have block scoping, which is to say, if statements, while statements, for loops etc, while they have curly braces, don't have their own lexical scope. Only functions have their own lexical scope.
</p>

</article>

<article>
	<h3>
		Execution Contexts
	</h3>
	<p>Execution contexts, also called "in memory scopes" are memory structures which are built up by a program when it runs. Certain rules govern which variables the program has access to at different points in the execution. Note that these are not the same as in memory objects, however. You can never store an array full of contexts.</p>
	<p>New execution contexts are created each time you run a function.</p>
</article>


<article>
<h3>Closures</h3>

<p>A closure is a function that remains available after its outer scopes have returned. It is not an intuitive name.</p>

<p>Here are three example methods for accessing a function once external functions have returned:</p>

<p>
	Passing the function into setTimeout().
</p>
<p>
	Returning the function from the outer scopes
</p>
<p>
	Saving the function into a global variable
</p>

<p>Having done this, the function nevertheless needs to "appear" within the original execution context of its outer scopes to work - so any variable defined in an outer scope will stay the same each time the closure is run.</p>

<p>The key use for this is refactoring code by taking any function that needs to repeat using the same inputs, and making it a closure, saving it with its input into a global array or object</p>

</article>

<footer>
<a href="../main.html">Return Home</a>
</footer>
</main>

<!-- <script src="../notes.js"> -->
<!-- </script> -->
</body>
</html>